---
layout : post
title : "二分搜索"
category : C++
duoshuo: true
date : 2014-11-19
tags : [C , C++ ,二分搜索 ]
SyntaxHihglighter: true
shTheme: shThemeMidnight # shThemeDefault  shThemeDjango  shThemeEclipse  shThemeEmacs  shThemeFadeToGrey  shThemeMidnight  shThemeRDark
---

**二分搜索针对的是有序数组x[0...n-1]中是否包含目标元素t**

已知 **n>=0** && **x[0]<=x[1]<=x[2]<=...<=x[n-1]**;当n=0时，数组为空，目标元素t与数组元素类型相同，查找位置记录于p中，若p为-1，表示t未找到，否则0=<p<=n-1 && x[p]=t。 

<!-- more -->

二分搜索通过持续跟踪包含目标元素t的范围来解决问题，通过将t与数组中的中间元素比较并抛弃一半的范围来缩小搜索范围，该过程持续进行，直到在数组中找到t或者确定包含t的范围为空时为止。在有n个元素的表中，二分搜索大约需要进行log2(n)次比较。

大致写了下例程，不通用也很死板，只为对比and满足我的日常需要，如果有必要的话，抽空我会变着法子去扩展它的。

<pre class="brush: c; ">
	...
	vector&lt;int&gt;vec{1,2,2,2,4,6,7,8,9,10};
	int begin = 0, end = vec.size() - 1,temp = 0, p = -1, search = 2;
	while (begin <= end)
	{
		temp = (begin + end) / 2;
		if (search == vec[temp])
		{
			p = temp;break;
		}
		else
		{
			if (search > vec[temp])
				begin = temp + 1;
			else
				end = temp - 1;
	
		}
	}
	if (p!=-1)
		cout << "..." << p<<endl;
	else
		cout << "..." << endl;
</pre>

发现一个现象，在使用上述二分搜索的时候，上述算法只是解决了一个最简单的问题，即目标元素是否存在，当数组中存在多个目标元素时，查找返回的目标元素位置可能仅仅是其中任意一个，而有时我们需要的恰好往往是出现目标元素的第一个位置，所以，上述程序需要变形。

<pre class="brush: c; ">
	/*
	*使用下标begin和end表示包含目标元素的范围
	*程序需要满足不变式x[begin]<t<<x[end] && begin<end
	*此外，假设数组元素数量n>=0 && x[-1]<t<=x[n](程序并不访问这两个假想的元素)
	*程序输出为目标元素在指定数组中出现的第一个位置。
	*/
	
	vector&lt;int&gt;vec{ 2, 2, 2,2, 4, 6, 7, 8, 9, 10 };
	int begin = -1;
	int end = vec.size();
	int search = 2;
	int temp;
	while (begin + 1 != end)
	{
		temp = (begin + end) / 2;
		if (vec[temp] < search)
			begin = temp;
		else 
			end = temp;
	}
	int p = end;
	if (p >= vec.size() || vec[p] != search)p = -1;
	cout << p << endl;
</pre>

由此，利用二分搜索获取到了当目标查找元素含有多个时，在指定数组出现的第一个位置，上述程序也可以通过以下变形，代码调优，可以对原始二分搜索进行加速。

**利用指定数组元素数目n=vec1.size()这个已知条件,不需要用begin和end表示上下限，而是通过下限begin和增量i来表示，使得begin+i=end**

程序代码确保i=2^j ,同时保证vec1[begin]<t&&vec1[begin+i]>=t

<pre class="brush: c; ">
	vector&lt;int&gt;vec1{ 1, 2, 2, 4, 4, 6, 7, 8, 9, 10 };
	int begin = -1, end = vec1.size(), search = 4,i=8;//10以内的最大2的整数次幂=8
	if (vec1[begin + 8] < search)begin = 2;
	while (i!=1)
	{
		i = i / 2;
		if (vec1[begin + i] < search)begin += i;
	}
	int p = begin + 1;
	if (p>end || vec1[p] != search)p = -1;
	cout << "p	=" << p << endl;
</pre>

通过将上述代码展开循环，可以消除循环控制和i/2的开销

<pre class="brush: c; ">
	int begin = -1, end = vec1.size(), search = 4;
	if (vec1[begin + 8] < search)begin = end - 8;
	if (vec1[begin + 4] < search)begin += 4;
	if (vec1[begin + 2] < search)begin += 2;
	if (vec1[begin + 1] < search)begin += 1;
	int p = begin + 1;
	if (p>end || vec1[p] != search)p = -1;
	cout << "p	=" << p << endl;
</pre>

